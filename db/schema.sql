-- Tickets Management System Database Schema

-- Enable RLS (Row Level Security)
alter table if exists "public"."tickets" enable row level security;

-- Create tickets table
create table if not exists "public"."tickets" (
  "id" bigint generated by default as identity primary key,
  "title" text not null,
  "description" text not null,
  "status" text not null default 'open',
  "priority" text not null default 'medium',
  "assignee_id" uuid references auth.users(id) null,
  "created_by" uuid references auth.users(id) null,
  "created_at" timestamp with time zone default timezone('utc'::text, now()) not null,
  "updated_at" timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Add constraints to limit status values
alter table if exists "public"."tickets" drop constraint if exists "tickets_status_check";
alter table "public"."tickets" add constraint "tickets_status_check" 
  check (status in ('open', 'in_progress', 'resolved', 'closed'));

-- Add constraints to limit priority values
alter table if exists "public"."tickets" drop constraint if exists "tickets_priority_check";
alter table "public"."tickets" add constraint "tickets_priority_check" 
  check (priority in ('low', 'medium', 'high', 'critical'));

-- Create comments table for ticket discussions
create table if not exists "public"."ticket_comments" (
  "id" bigint generated by default as identity primary key,
  "ticket_id" bigint not null references tickets(id) on delete cascade,
  "content" text not null,
  "user_id" uuid references auth.users(id) null,
  "created_at" timestamp with time zone default timezone('utc'::text, now()) not null,
  "updated_at" timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create ticket history table for audit trail
create table if not exists "public"."ticket_history" (
  "id" bigint generated by default as identity primary key,
  "ticket_id" bigint not null references tickets(id) on delete cascade,
  "field_name" text not null,
  "old_value" text,
  "new_value" text,
  "changed_by" uuid references auth.users(id) null,
  "created_at" timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create tags table
create table if not exists "public"."tags" (
  "id" bigint generated by default as identity primary key,
  "name" text not null unique,
  "color" text not null default '#3b82f6',
  "created_at" timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create junction table for ticket tags (many-to-many)
create table if not exists "public"."ticket_tags" (
  "ticket_id" bigint not null references tickets(id) on delete cascade,
  "tag_id" bigint not null references tags(id) on delete cascade,
  "created_at" timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key ("ticket_id", "tag_id")
);

-- Create indexes for better performance
create index if not exists "tickets_status_idx" on "public"."tickets" ("status");
create index if not exists "tickets_priority_idx" on "public"."tickets" ("priority");
create index if not exists "tickets_created_at_idx" on "public"."tickets" ("created_at");
create index if not exists "tickets_assignee_id_idx" on "public"."tickets" ("assignee_id");
create index if not exists "ticket_comments_ticket_id_idx" on "public"."ticket_comments" ("ticket_id");
create index if not exists "ticket_history_ticket_id_idx" on "public"."ticket_history" ("ticket_id");

-- Create function to update updated_at timestamp
create or replace function "public"."update_updated_at_column"()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Create triggers to automatically update updated_at
drop trigger if exists "update_tickets_updated_at" on "public"."tickets";
create trigger "update_tickets_updated_at"
before update on "public"."tickets"
for each row execute function update_updated_at_column();

drop trigger if exists "update_ticket_comments_updated_at" on "public"."ticket_comments";
create trigger "update_ticket_comments_updated_at"
before update on "public"."ticket_comments"
for each row execute function update_updated_at_column();

-- Create function to track ticket history
create or replace function "public"."track_ticket_history"()
returns trigger as $$
declare
  field_name text;
  old_value text;
  new_value text;
begin
  if (TG_OP = 'UPDATE') then
    -- Check each field for changes
    if old.title <> new.title then
      insert into ticket_history (ticket_id, field_name, old_value, new_value, changed_by)
      values (new.id, 'title', old.title, new.title, auth.uid());
    end if;
    
    if old.description <> new.description then
      insert into ticket_history (ticket_id, field_name, old_value, new_value, changed_by)
      values (new.id, 'description', old.description, new.description, auth.uid());
    end if;
    
    if old.status <> new.status then
      insert into ticket_history (ticket_id, field_name, old_value, new_value, changed_by)
      values (new.id, 'status', old.status, new.status, auth.uid());
    end if;
    
    if old.priority <> new.priority then
      insert into ticket_history (ticket_id, field_name, old_value, new_value, changed_by)
      values (new.id, 'priority', old.priority, new.priority, auth.uid());
    end if;
    
    if old.assignee_id is distinct from new.assignee_id then
      insert into ticket_history (ticket_id, field_name, old_value, new_value, changed_by)
      values (new.id, 'assignee_id', old.assignee_id::text, new.assignee_id::text, auth.uid());
    end if;
  end if;
  
  return new;
end;
$$ language plpgsql security definer;

-- Create trigger for ticket history tracking
drop trigger if exists "track_ticket_changes" on "public"."tickets";
create trigger "track_ticket_changes"
after update on "public"."tickets"
for each row execute function track_ticket_history();

-- Sample data for testing (uncomment to use)
/*
-- Insert sample tags
insert into tags (name, color) values 
  ('bug', '#ef4444'),
  ('feature', '#3b82f6'),
  ('enhancement', '#10b981'),
  ('documentation', '#f59e0b'),
  ('question', '#8b5cf6');

-- Insert sample tickets
insert into tickets (title, description, status, priority) values 
  ('Login page not working', 'Users are unable to log in using their credentials. The login button does not respond when clicked.', 'open', 'high'),
  ('Add dark mode support', 'Implement dark mode theme for better user experience in low-light environments.', 'in_progress', 'medium'),
  ('Improve documentation', 'Update API documentation with new endpoints and examples.', 'open', 'low'),
  ('Performance issues on dashboard', 'Dashboard is loading slowly when there are more than 100 items.', 'open', 'critical'),
  ('Fix typo on homepage', 'There is a typo in the welcome message on the homepage.', 'closed', 'low');

-- Link tickets with tags
insert into ticket_tags (ticket_id, tag_id) values 
  (1, 1), -- Login page (bug)
  (2, 2), -- Dark mode (feature)
  (2, 3), -- Dark mode (enhancement)
  (3, 4), -- Documentation (documentation)
  (4, 1), -- Performance (bug)
  (4, 3), -- Performance (enhancement)
  (5, 1); -- Typo (bug)
*/

-- RLS Policies (enable after setting up authentication)
/*
-- Policy for viewing tickets (everyone can view)
create policy "Anyone can view tickets"
  on tickets for select
  using (true);

-- Policy for inserting tickets (authenticated users only)
create policy "Authenticated users can create tickets"
  on tickets for insert
  with check (auth.role() = 'authenticated');

-- Policy for updating tickets (only assignee or admin can update)
create policy "Only assignee or admin can update tickets"
  on tickets for update
  using (
    auth.uid() = assignee_id or 
    auth.uid() = created_by or
    auth.role() = 'admin'
  );
*/ 